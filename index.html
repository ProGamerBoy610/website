<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discord Bot Runner - 24/7</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .status {
            background: rgba(67, 160, 71, 0.2);
            border: 2px solid #43a047;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 30px;
        }
        .status h2 {
            margin: 0;
            color: #66bb6a;
        }
        .logs {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 15px;
            height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            border: 2px solid rgba(255,255,255,0.2);
            margin-bottom: 20px;
        }
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-left: 3px solid #5865f2;
            padding-left: 10px;
        }
        .log-success { border-left-color: #43a047; color: #66bb6a; }
        .log-error { border-left-color: #f44336; color: #ef5350; }
        .log-info { border-left-color: #2196f3; color: #64b5f6; }
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        button {
            background: linear-gradient(135deg, #5865f2, #3b82f6);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(88, 101, 242, 0.3);
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(88, 101, 242, 0.4);
        }
        .start-btn { background: linear-gradient(135deg, #43a047, #66bb6a); }
        .stop-btn { background: linear-gradient(135deg, #f44336, #ef5350); }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .stat-card {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid rgba(255,255,255,0.2);
        }
        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .instructions {
            background: rgba(255, 193, 7, 0.2);
            border: 2px solid #ffc107;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }
        .instructions h3 {
            margin-top: 0;
            color: #ffeb3b;
        }
        .code-section {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü§ñ Discord Bot Runner 24/7</h1>
        
        <div class="instructions">
            <h3>üìã Setup Instructions:</h3>
            <p><strong>1.</strong> Paste your Discord bot code in the JavaScript section below</p>
            <p><strong>2.</strong> Make sure your bot token is included in the code</p>
            <p><strong>3.</strong> Click "Start Bot" to run your bot 24/7</p>
            <p><strong>4.</strong> Upload this entire HTML file to any free hosting (Netlify, Vercel, GitHub Pages)</p>
            <div class="code-section">
                <strong>Note:</strong> This website will keep your bot running even when your PC is off!
            </div>
        </div>
        
        <div class="status" id="botStatus">
            <h2 id="statusText">üî¥ Bot Offline - Click Start to Begin</h2>
        </div>
        
        <div class="controls">
            <button class="start-btn" onclick="startBot()">üöÄ Start Bot</button>
            <button class="stop-btn" onclick="stopBot()">‚èπÔ∏è Stop Bot</button>
            <button onclick="clearLogs()">üóëÔ∏è Clear Logs</button>
            <button onclick="restartBot()">üîÑ Restart Bot</button>
        </div>
        
        <div class="stats">
            <div class="stat-card">
                <div class="stat-number" id="uptime">00:00:00</div>
                <div>Uptime</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="servers">0</div>
                <div>Servers</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="users">0</div>
                <div>Total Users</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="commands">0</div>
                <div>Commands Used</div>
            </div>
        </div>
        
        <h3>üìú Bot Logs</h3>
        <div class="logs" id="logs">
            <div class="log-entry log-info">üîß Bot runner initialized. Waiting for start command...</div>
        </div>
    </div>

    <script>
        // Bot status variables
        let botRunning = false;
        let startTime = null;
        let botStats = {
            servers: 0,
            users: 0,
            commands: 0
        };

       
const { Client, GatewayIntentBits, ActionRowBuilder, ButtonBuilder, ButtonStyle, ModalBuilder, TextInputBuilder, TextInputStyle, Events, InteractionType, EmbedBuilder } = require('discord.js');

const client = new Client({ 
    intents: [
        GatewayIntentBits.Guilds, 
        GatewayIntentBits.GuildMessages, 
        GatewayIntentBits.MessageContent
    ] 
});

// --- Temporary storage ---
const submissions = new Map(); // userId => formData
const userTasks = new Map(); // userId => { link, expectedOutput, expiresAt }
const keySystemSetup = new Map(); // userId => { waitingForKey: boolean }

// --- Predefined links and outputs ---
const links = {
    "https://linkvertise.com/32828": "6234767",
    "https://linkvertise.com/32dgdf8": "62etdfgdf767",
    "https://linkvertise.com/abcd12": "abc1234",
    "https://linkvertise.com/xyz987": "xyz5678",
    "https://linkvertise.com/test123": "test456",
    "https://linkvertise.com/demo789": "demo321"
};

// Your Discord user ID
const ADMIN_USER_ID = '1308399783936921632';

// --- Helper Functions ---
function isExpired(expiresAt) {
    return Date.now() > expiresAt;
}

function cleanupExpiredTasks() {
    for (const [userId, task] of userTasks.entries()) {
        if (isExpired(task.expiresAt)) {
            submissions.delete(userId);
            userTasks.delete(userId);
            keySystemSetup.delete(userId);
            console.log(`üßπ Cleaned up expired task for user ${userId}`);
        }
    }
}

// Clean up expired tasks every 10 minutes
setInterval(cleanupExpiredTasks, 10 * 60 * 1000);

// --- Bot Ready ---
client.once('ready', () => {
    console.log(`‚úÖ Bot is online as ${client.user.tag}!`);
    console.log(`üìä Guilds: ${client.guilds.cache.size}`);
    console.log(`üë§ Admin ID set to: ${ADMIN_USER_ID}`);
});

// --- Command to send apply button ---
client.on('messageCreate', async (message) => {
    if (message.content === "!apply" && !message.author.bot) {
        console.log(`üìù Apply command used by ${message.author.tag}`);
        
        const embed = new EmbedBuilder()
            .setColor('#0099ff')
            .setTitle('üöÄ Roblox Script Submission')
            .setDescription('Submit your Roblox script for review!\n\n**Process:**\n1Ô∏è‚É£ Fill out the form with script details\n2Ô∏è‚É£ Choose if you want a key system\n3Ô∏è‚É£ Upload an image (optional)\n4Ô∏è‚É£ Complete verification task (1 attempt only)\n5Ô∏è‚É£ Send verification code')
            .addFields(
                { name: '‚ö†Ô∏è Important', value: '‚Ä¢ You get **only 1 attempt** for verification\n‚Ä¢ Submissions expire after **48 hours**\n‚Ä¢ Key system is completely optional', inline: false }
            )
            .setFooter({ text: 'Click the button below to start!' });

        const row = new ActionRowBuilder().addComponents(
            new ButtonBuilder()
                .setCustomId('open_form')
                .setLabel('üìù Start Application')
                .setStyle(ButtonStyle.Primary)
                .setEmoji('üìù')
        );

        await message.channel.send({ embeds: [embed], components: [row] });
    }
});

// --- Handle message-based key system setup ---
client.on('messageCreate', async (message) => {
    if (message.author.bot) return;
    
    const userId = message.author.id;
    const keySetup = keySystemSetup.get(userId);
    
    if (!keySetup) return;
    
    const formData = submissions.get(userId);
    if (!formData) {
        keySystemSetup.delete(userId);
        return;
    }
    
    if (keySetup.waitingForKey) {
        // User is sending the key
        const key = message.content.trim();
        if (key.length < 1 || key.length > 100) {
            await message.reply("‚ùå **Key must be between 1-100 characters!** Please try again:");
            return;
        }
        
        formData.scriptKey = key;
        keySetup.waitingForKey = false;
        keySystemSetup.delete(userId);
        
        formData.hasKeySystem = true;
        submissions.set(userId, formData);
        
        await message.reply("‚úÖ **Key saved!** This key is for admin use only to verify and ensure no additional activities.");
        await showFinalConfirmation(message, formData);
        return;
    }
});

// --- Handle all interactions ---
client.on(Events.InteractionCreate, async (interaction) => {
    console.log(`üîÑ Interaction received: ${interaction.type} - ${interaction.customId || 'no customId'}`);
    
    try {
        // 1Ô∏è‚É£ Open form modal
        if (interaction.isButton() && interaction.customId === 'open_form') {
            console.log(`üë§ ${interaction.user.tag} clicked open form button`);
            
            // Check if user already has pending submission
            if (submissions.has(interaction.user.id)) {
                const task = userTasks.get(interaction.user.id);
                if (task && isExpired(task.expiresAt)) {
                    // Clean up expired submission
                    submissions.delete(interaction.user.id);
                    userTasks.delete(interaction.user.id);
                    keySystemSetup.delete(interaction.user.id);
                } else {
                    await interaction.reply({ 
                        content: "‚ùå **You already have a pending submission!**\nComplete your current task or wait for it to expire (48 hours).", 
                        ephemeral: true 
                    });
                    return;
                }
            }

            const modal = new ModalBuilder()
                .setCustomId('script_form')
                .setTitle('üéÆ Roblox Script Submission');

            // Basic form fields
            const nameInput = new TextInputBuilder()
                .setCustomId('script_name')
                .setLabel('Script Name')
                .setStyle(TextInputStyle.Short)
                .setPlaceholder('Enter your script name...')
                .setMaxLength(100)
                .setRequired(true);

            const gameLinkInput = new TextInputBuilder()
                .setCustomId('game_link')
                .setLabel('Roblox Game Link')
                .setStyle(TextInputStyle.Short)
                .setPlaceholder('https://www.roblox.com/games/...')
                .setRequired(true);

            const featuresInput = new TextInputBuilder()
                .setCustomId('features')
                .setLabel('Script Features')
                .setStyle(TextInputStyle.Paragraph)
                .setPlaceholder('List the main features of your script...')
                .setRequired(true);

            const scriptInput = new TextInputBuilder()
                .setCustomId('script_code')
                .setLabel('Script Code')
                .setStyle(TextInputStyle.Paragraph)
                .setPlaceholder('Paste your Lua/Roblox script here...')
                .setRequired(true);

            const descriptionInput = new TextInputBuilder()
                .setCustomId('description')
                .setLabel('Script Description')
                .setStyle(TextInputStyle.Paragraph)
                .setPlaceholder('Describe your script, how it works, etc...')
                .setRequired(false);

            // Add components to modal
            modal.addComponents(
                new ActionRowBuilder().addComponents(nameInput),
                new ActionRowBuilder().addComponents(gameLinkInput),
                new ActionRowBuilder().addComponents(featuresInput),
                new ActionRowBuilder().addComponents(scriptInput),
                new ActionRowBuilder().addComponents(descriptionInput)
            );

            await interaction.showModal(modal);
        }

        // 2Ô∏è‚É£ Handle form submission
        else if (interaction.type === InteractionType.ModalSubmit && interaction.customId === 'script_form') {
            console.log(`üìã Form submitted by ${interaction.user.tag}`);

            const formData = {
                scriptName: interaction.fields.getTextInputValue('script_name'),
                gameLink: interaction.fields.getTextInputValue('game_link'),
                scriptCode: interaction.fields.getTextInputValue('script_code'),
                features: interaction.fields.getTextInputValue('features'),
                description: interaction.fields.getTextInputValue('description') || 'No description provided',
                hasKeySystem: false,
                scriptKey: '',
                userId: interaction.user.id,
                username: interaction.user.tag,
                timestamp: new Date(),
                expiresAt: Date.now() + (48 * 60 * 60 * 1000),
                imageUrl: null
            };

            // Store the form data
            submissions.set(interaction.user.id, formData);
            console.log(`üíæ Form data saved for user ${interaction.user.tag}`);

            // Show key system choice
            const keySystemEmbed = new EmbedBuilder()
                .setColor('#ffaa00')
                .setTitle('üîë Key System Setup')
                .setDescription('**Do you want your script to have a key system?**\n\nKey systems require users to enter a specific key to access your script.')
                .addFields(
                    { name: '‚úÖ With Key System', value: '‚Ä¢ More secure\n‚Ä¢ You provide the key\n‚Ä¢ Users must enter key to use script', inline: true },
                    { name: '‚ùå No Key System', value: '‚Ä¢ Public access\n‚Ä¢ No key required\n‚Ä¢ Anyone can use the script', inline: true }
                )
                .setFooter({ text: 'Choose your preferred option below' });

            const keySystemRow = new ActionRowBuilder().addComponents(
                new ButtonBuilder()
                    .setCustomId('enable_key_system')
                    .setLabel('‚úÖ Enable Key System')
                    .setStyle(ButtonStyle.Success)
                    .setEmoji('üîê'),
                new ButtonBuilder()
                    .setCustomId('disable_key_system')
                    .setLabel('‚ùå No Key System')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('üö´')
            );

            await interaction.reply({ embeds: [keySystemEmbed], components: [keySystemRow], ephemeral: true });
        }

        // 3Ô∏è‚É£ Handle key system enabled
        else if (interaction.isButton() && interaction.customId === 'enable_key_system') {
            console.log(`üîë ${interaction.user.tag} enabled key system`);
            
            keySystemSetup.set(interaction.user.id, { waitingForKey: true });
            
            await interaction.reply({
                content: "üîë **Key System Enabled!**\n\nPlease type your script key in the chat (the key users will need to enter):",
                ephemeral: true
            });
            
            await interaction.followUp({
                content: `üîë **${interaction.user}**, please send your script key now (1-100 characters):`,
                ephemeral: false
            });
        }

        // 4Ô∏è‚É£ Handle key system disabled
        else if (interaction.isButton() && interaction.customId === 'disable_key_system') {
            console.log(`‚ùå ${interaction.user.tag} disabled key system`);
            
            const formData = submissions.get(interaction.user.id);
            if (!formData) {
                await interaction.reply({ content: "‚ùå **Form data not found!** Please start over.", ephemeral: true });
                return;
            }

            // Update form data with no key system
            formData.hasKeySystem = false;
            formData.scriptKey = '';
            submissions.set(interaction.user.id, formData);

            await showFinalConfirmationInteraction(interaction, formData);
        }

        // 5Ô∏è‚É£ Handle image upload request
        else if (interaction.isButton() && interaction.customId === 'upload_image') {
            await interaction.reply({
                content: "üì∑ **Upload your image now!**\n\nSend an image in this channel within 2 minutes. First image will be saved.",
                ephemeral: true
            });

            const imageFilter = (message) => {
                return message.author.id === interaction.user.id && message.attachments.size > 0;
            };

            const collector = interaction.channel.createMessageCollector({
                filter: imageFilter,
                max: 1,
                time: 2 * 60 * 1000
            });

            collector.on('collect', (message) => {
                const attachment = message.attachments.first();
                if (attachment.contentType && attachment.contentType.startsWith('image/')) {
                    const formData = submissions.get(interaction.user.id);
                    if (formData) {
                        formData.imageUrl = attachment.url;
                        submissions.set(interaction.user.id, formData);
                        message.reply("‚úÖ **Image uploaded successfully!** You can now confirm your submission.");
                    }
                }
            });
        }

        // 6Ô∏è‚É£ Handle final confirmation
        else if (interaction.isButton() && interaction.customId === 'confirm_submission') {
            console.log(`‚úÖ Final confirmation clicked by ${interaction.user.tag}`);
            
            const formData = submissions.get(interaction.user.id);
            if (!formData) {
                await interaction.reply({ 
                    content: "‚ùå **Form data not found!** Please start over with !apply.", 
                    ephemeral: true 
                });
                return;
            }

            // Check if expired
            if (isExpired(formData.expiresAt)) {
                submissions.delete(interaction.user.id);
                await interaction.reply({
                    content: "‚ùå **Your submission has expired!** Please start over with !apply.",
                    ephemeral: true
                });
                return;
            }

            // Select random verification task
            const linkEntries = Object.entries(links);
            const randomIndex = Math.floor(Math.random() * linkEntries.length);
            const [randomLink, expectedCode] = linkEntries[randomIndex];

            // Store verification task
            userTasks.set(interaction.user.id, {
                link: randomLink,
                expectedOutput: expectedCode,
                expiresAt: formData.expiresAt
            });

            console.log(`üîó Verification task assigned to ${interaction.user.tag}: ${randomLink} -> ${expectedCode}`);

            // Create verification embed
            const verificationEmbed = new EmbedBuilder()
                .setColor('#ff6600')
                .setTitle('üîê Final Step: Verification')
                .setDescription('**Complete this verification to submit your script.**')
                .addFields(
                    { name: 'üîó Verification Link', value: `**[Click Here to Complete Task](${randomLink})**`, inline: false },
                    { name: 'üìù Instructions:', value: '1. Click the link above\n2. Complete the Linkvertise task\n3. Copy the code you get\n4. Send that code in this chat', inline: false },
                    { name: '‚ö†Ô∏è IMPORTANT:', value: '‚Ä¢ **ONLY 1 ATTEMPT** - no second chances!\n‚Ä¢ Code is case-sensitive\n‚Ä¢ Expires <t:' + Math.floor(formData.expiresAt / 1000) + ':R>', inline: false }
                )
                .setFooter({ text: 'ONE CHANCE ONLY - Be careful!' })
                .setTimestamp();

            await interaction.update({ embeds: [verificationEmbed], components: [] });

            await interaction.followUp({
                content: `üîó **Direct Link:** ${randomLink}\n\n‚ö†Ô∏è **Remember: Only 1 attempt! and type the code**`,
                ephemeral: true
            });
        }

    } catch (error) {
        console.error('‚ùå Error in interaction handler:', error);
        if (!interaction.replied && !interaction.deferred) {
            try {
                await interaction.reply({
                    content: '‚ùå **Something went wrong!** Please try again or contact support.',
                    ephemeral: true
                });
            } catch (e) {
                console.error('Failed to send error response:', e);
            }
        }
    }
});

// Helper function for message-based final confirmation
async function showFinalConfirmation(message, formData) {
    const confirmEmbed = new EmbedBuilder()
        .setColor('#00ff00')
        .setTitle('‚úÖ Submission Ready!')
        .setDescription('**Review your submission:**')
        .addFields(
            { name: 'üìù Script Name', value: formData.scriptName, inline: true },
            { name: 'üéÆ Game Link', value: formData.gameLink, inline: true },
            { name: 'üîë Key System', value: formData.hasKeySystem ? `‚úÖ Enabled\nKey: ||${formData.scriptKey}|| (This key is for admin use only to verify and ensure no additional activities)` : '‚ùå Disabled', inline: true },
            { name: '‚ö° Features', value: formData.features.length > 100 ? formData.features.substring(0, 100) + '...' : formData.features, inline: false },
            { name: 'üìÑ Description', value: formData.description.length > 100 ? formData.description.substring(0, 100) + '...' : formData.description, inline: false },
            { name: '‚è∞ Expires', value: `<t:${Math.floor(formData.expiresAt / 1000)}:R>`, inline: false }
        )
        .setFooter({ text: 'Upload image (optional) then confirm to proceed' });

    const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
            .setCustomId('upload_image')
            .setLabel('üì∑ Upload Image')
            .setStyle(ButtonStyle.Secondary)
            .setEmoji('üñºÔ∏è'),
        new ButtonBuilder()
            .setCustomId('confirm_submission')
            .setLabel('‚úÖ Confirm & Start Verification')
            .setStyle(ButtonStyle.Success)
            .setEmoji('üîó')
    );

    await message.reply({ embeds: [confirmEmbed], components: [row] });
}

// Helper function for interaction-based final confirmation
async function showFinalConfirmationInteraction(interaction, formData) {
    const confirmEmbed = new EmbedBuilder()
        .setColor('#00ff00')
        .setTitle('‚úÖ Submission Ready!')
        .setDescription('**Review your submission:**')
        .addFields(
            { name: 'üìù Script Name', value: formData.scriptName, inline: true },
            { name: 'üéÆ Game Link', value: formData.gameLink, inline: true },
            { name: 'üîë Key System', value: formData.hasKeySystem ? `‚úÖ Enabled\nKey: ||${formData.scriptKey}|| (This key is for admin use only to verify and ensure no additional activities)` : '‚ùå Disabled', inline: true },
            { name: '‚ö° Features', value: formData.features.length > 100 ? formData.features.substring(0, 100) + '...' : formData.features, inline: false },
            { name: 'üìÑ Description', value: formData.description.length > 100 ? formData.description.substring(0, 100) + '...' : formData.description, inline: false },
            { name: '‚è∞ Expires', value: `<t:${Math.floor(formData.expiresAt / 1000)}:R>`, inline: false }
        )
        .setFooter({ text: 'Upload image (optional) then confirm to proceed' });

    const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
            .setCustomId('upload_image')
            .setLabel('üì∑ Upload Image')
            .setStyle(ButtonStyle.Secondary)
            .setEmoji('üñºÔ∏è'),
        new ButtonBuilder()
            .setCustomId('confirm_submission')
            .setLabel('‚úÖ Confirm & Start Verification')
            .setStyle(ButtonStyle.Success)
            .setEmoji('üîó')
    );

    await interaction.reply({ embeds: [confirmEmbed], components: [row], ephemeral: true });
}

// 7Ô∏è‚É£ Listen for verification codes
client.on('messageCreate', async (message) => {
    // Skip bot messages and commands
    if (message.author.bot || message.content.startsWith('!')) return;

    const userId = message.author.id;
    const task = userTasks.get(userId);

    // Only process if user has an active verification task
    if (!task) return;

    // Skip if user is setting up key system
    if (keySystemSetup.has(userId)) return;

    // Check if task is expired
    if (isExpired(task.expiresAt)) {
        submissions.delete(userId);
        userTasks.delete(userId);
        await message.reply("‚ùå **Your verification task has expired!** Please start over with !apply.");
        return;
    }

    const userCode = message.content.trim();
    console.log(`üîç Verification attempt by ${message.author.tag}: "${userCode}" (expected: "${task.expectedOutput}")`);

    // Check if the code matches (ONLY ONE ATTEMPT)
    if (userCode === task.expectedOutput) {
        console.log(`‚úÖ Verification successful for ${message.author.tag}`);

        const formData = submissions.get(userId);
        if (!formData) {
            await message.reply("‚ùå **Form data not found!** Please start over with !apply.");
            userTasks.delete(userId);
            return;
        }

        try {
            // Send to admin
            const admin = await client.users.fetch(ADMIN_USER_ID);
            
            const adminEmbed = new EmbedBuilder()
                .setColor('#00ff00')
                .setTitle('‚úÖ NEW VERIFIED SCRIPT SUBMISSION')
                .setDescription(`**Submitted by:** ${formData.username}\n**User ID:** ${formData.userId}`)
                .addFields(
                    { name: 'üìù Script Name', value: formData.scriptName, inline: true },
                    { name: 'üéÆ Game Link', value: formData.gameLink, inline: true },
                    { name: 'üìÖ Submitted', value: formData.timestamp.toLocaleString(), inline: true },
                    { name: 'üîë Key System', value: formData.hasKeySystem ? `‚úÖ Enabled\nKey: ${formData.scriptKey} (This key is for admin use only to verify and ensure no additional activities)` : '‚ùå Disabled', inline: true },
                    { name: '‚ö° Features', value: formData.features, inline: false },
                    { name: 'üìÑ Description', value: formData.description, inline: false }
                )
                .setTimestamp()
                .setThumbnail(message.author.displayAvatarURL());

            if (formData.imageUrl) {
                adminEmbed.setImage(formData.imageUrl);
            }

            await admin.send({ embeds: [adminEmbed] });
            await admin.send(`**üíª Script Code from ${formData.username}:**\n\`\`\`lua\n${formData.scriptCode}\`\`\``);

            console.log(`üì® Submission sent to admin for ${message.author.tag}`);

            // Clean up data
            submissions.delete(userId);
            userTasks.delete(userId);

            // Confirm to user
            const successEmbed = new EmbedBuilder()
                .setColor('#00ff00')
                .setTitle('üéâ Verification Complete!')
                .setDescription('**Your script has been successfully submitted!**')
                .addFields(
                    { name: 'üìù Script Name', value: formData.scriptName, inline: true },
                    { name: 'üîë Key System', value: formData.hasKeySystem ? '‚úÖ Enabled' : '‚ùå Disabled', inline: true },
                    { name: '‚úÖ Status', value: 'Submitted for Review', inline: true }
                )
                .setFooter({ text: 'Thank you! Admin will review soon.' })
                .setTimestamp();

            await message.reply({ embeds: [successEmbed] });

        } catch (error) {
            console.error('‚ùå Error sending to admin:', error);
            await message.reply("‚ùå **Verification successful but failed to send to admin.** Contact support!");
        }

    } else {
        // Wrong code - ONE ATTEMPT ONLY
        console.log(`‚ùå Wrong code from ${message.author.tag}`);
        
        submissions.delete(userId);
        userTasks.delete(userId);

        const failEmbed = new EmbedBuilder()
            .setColor('#ff0000')
            .setTitle('‚ùå Verification Failed')
            .setDescription('**Incorrect verification code.**\n\n**Your submission has been cancelled (only 1 attempt allowed).**')
            .addFields(
                { name: 'üîÑ Start Over', value: 'Use `!apply` to submit again', inline: false },
                { name: 'üí° Tips', value: '‚Ä¢ Complete the full task\n‚Ä¢ Copy exact code\n‚Ä¢ Check for extra spaces', inline: false }
            )
            .setFooter({ text: 'Be more careful next time!' });

        await message.reply({ embeds: [failEmbed] });
    }
});

// Error handling
client.on('error', (error) => {
    console.error('‚ùå Discord client error:', error);
});

process.on('unhandledRejection', (error) => {
    console.error('‚ùå Unhandled promise rejection:', error);
});

// Login
client.login('MTQxMzkyNDQ2NDI5NDQ5ODQwNQ.GVY-qm.987kh7HwcpVYxFOaWEoQszS9Im4eOmOzsHwWUI')
    .then(() => console.log('üîê Login successful!'))
    .catch(error => console.error('‚ùå Login failed:', error));
        
        // Helper functions
        function log(message, type = "info") {
            const logs = document.getElementById('logs');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`;
            logs.appendChild(entry);
            logs.scrollTop = logs.scrollHeight;
        }
        
        function updateStatus(running, text) {
            const status = document.getElementById('botStatus');
            const statusText = document.getElementById('statusText');
            
            botRunning = running;
            statusText.textContent = text;
            
            if (running) {
                status.style.background = "rgba(67, 160, 71, 0.2)";
                status.style.borderColor = "#43a047";
                startTime = new Date();
                updateUptime();
            } else {
                status.style.background = "rgba(244, 67, 54, 0.2)";
                status.style.borderColor = "#f44336";
                startTime = null;
            }
        }
        
        function updateStatsDisplay() {
            document.getElementById('servers').textContent = botStats.servers;
            document.getElementById('users').textContent = botStats.users;
            document.getElementById('commands').textContent = botStats.commands;
        }
        
        function updateUptime() {
            if (startTime) {
                setInterval(() => {
                    if (botRunning && startTime) {
                        const now = new Date();
                        const diff = now - startTime;
                        const hours = Math.floor(diff / 3600000);
                        const minutes = Math.floor((diff % 3600000) / 60000);
                        const seconds = Math.floor((diff % 60000) / 1000);
                        
                        document.getElementById('uptime').textContent = 
                            `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    }
                }, 1000);
            }
        }
        
        // Control functions
        async function startBot() {
            if (botRunning) {
                log("‚ö†Ô∏è Bot is already running!", "info");
                return;
            }
            
            log("üöÄ Starting Discord bot...", "info");
            updateStatus(false, "üü° Bot Starting...");
            
            try {
                await runDiscordBot();
            } catch (error) {
                log("‚ùå Failed to start bot: " + error.message, "error");
                updateStatus(false, "üî¥ Bot Failed to Start");
            }
        }
        
        function stopBot() {
            if (!botRunning) {
                log("‚ö†Ô∏è Bot is not running!", "info");
                return;
            }
            
            log("‚èπÔ∏è Stopping Discord bot...", "info");
            updateStatus(false, "üî¥ Bot Offline");
            log("‚úÖ Bot stopped successfully", "success");
        }
        
        function restartBot() {
            if (botRunning) {
                log("üîÑ Restarting bot...", "info");
                stopBot();
                setTimeout(() => startBot(), 2000);
            } else {
                startBot();
            }
        }
        
        function clearLogs() {
            const logs = document.getElementById('logs');
            logs.innerHTML = '<div class="log-entry log-info">üóëÔ∏è Logs cleared</div>';
        }
        
        // Auto-start bot when page loads (for 24/7 operation)
        window.addEventListener('load', function() {
            log("üåê Website loaded - Bot runner ready", "success");
            log("üí° Tip: Click 'Start Bot' to begin running your Discord bot 24/7", "info");
            
            // Uncomment the next line to auto-start bot when website loads
            // setTimeout(() => startBot(), 3000);
        });
        
        // Keep website alive (prevents hosting services from sleeping)
        setInterval(() => {
            fetch(window.location.href).catch(() => {});
        }, 300000); // Ping every 5 minutes
        
        // Prevent page from sleeping on mobile
        let wakeLock = null;
        if ('wakeLock' in navigator) {
            navigator.wakeLock.request('screen').then(lock => {
                wakeLock = lock;
                log("üîí Screen wake lock acquired - page will stay active", "info");
            });
        }
    </script>
    
    <!-- 
    ===================================
    INSTRUCTIONS FOR ADDING YOUR BOT CODE:
    ===================================
    
    1. Find the section marked "=== PASTE YOUR DISCORD BOT CODE HERE ===" above
    
    2. Replace the runDiscordBot() function with your actual Discord bot code
    
    3. Your bot code should include:
       - const { Client, GatewayIntentBits, ... } = require('discord.js');
       - All your bot event handlers (client.on('ready'), client.on('messageCreate'), etc.)
       - Your bot login: client.login('your-bot-token')
    
    4. Make sure to wrap your bot code in try/catch blocks for error handling
    
    5. Save this HTML file and upload to:
       - Netlify.com (drag and drop)
       - Vercel.com (upload file)
       - GitHub Pages (create repository)
       - Any free web hosting service
    
    6. Your bot will run 24/7 even when your PC is off!
    
    NOTE: This is a client-side implementation. For production use, consider:
    - Using proper Node.js hosting (Railway, Render, Heroku)
    - Environment variables for bot tokens
    - Server-side bot execution
    -->
</body>
</html>
